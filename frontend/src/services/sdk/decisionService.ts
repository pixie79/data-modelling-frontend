/**
 * Decision Service
 * Handles MADR Architecture Decision Records via SDK 1.14.0+
 *
 * SDK 1.14.0 WASM Methods:
 * - parse_decision_yaml(yaml: string) -> JSON string
 * - parse_decision_index_yaml(yaml: string) -> JSON string
 * - export_decision_to_yaml(decision_json: string) -> YAML string
 * - export_decision_to_markdown(decision_json: string) -> Markdown string
 * - export_decision_to_branded_markdown(decision_json, branding_json?) -> Markdown string
 * - export_decision_to_pdf(decision_json, branding_json?) -> JSON with base64 PDF
 * - create_decision(number, title, context, decision) -> JSON string
 * - create_decision_index() -> JSON string
 * - add_decision_to_index(index_json, decision_json, filename) -> JSON string
 * - get_default_pdf_branding() -> JSON string
 * - get_default_markdown_branding() -> JSON string
 *
 * NOTE: WASM SDK works with YAML strings, not file paths.
 * File I/O must be handled by the application layer.
 */

import { sdkLoader } from './sdkLoader';
import {
  frontendDecisionToSDK,
  sdkDecisionToFrontend,
  sdkDecisionIndexToFrontend,
  frontendDecisionIndexToSDK,
} from './sdkTypeConverters';
import type {
  Decision,
  DecisionIndex,
  DecisionIndexEntry,
  DecisionFilter,
  DecisionOption,
} from '@/types/decision';
import {
  DecisionStatus,
  DecisionCategory,
  isValidStatusTransition,
  formatDecisionNumber,
  generateDecisionNumber,
} from '@/types/decision';

/**
 * PDF Export Result from SDK
 */
export interface PDFExportResult {
  data: string; // Base64-encoded PDF data
  filename: string;
  mimeType: string;
}

/**
 * Branding configuration for PDF/Markdown export
 */
export interface BrandingConfig {
  companyName?: string;
  logoUrl?: string;
  primaryColor?: string;
  secondaryColor?: string;
  fontFamily?: string;
  headerText?: string;
  footerText?: string;
}

/**
 * Default Open Data Modelling branding
 */
export const DEFAULT_BRANDING: BrandingConfig = {
  companyName: 'Open Data Modelling',
  primaryColor: '#2563eb',
  secondaryColor: '#1e40af',
  fontFamily: 'Inter, system-ui, sans-serif',
  footerText: 'Generated by Open Data Modelling',
};

/**
 * Decision Service for SDK 1.14.0+ decision management
 *
 * This service provides methods to work with decisions using the SDK.
 * In WASM mode, it works with YAML/JSON strings rather than file paths.
 */
class DecisionService {
  /**
   * Check if decision features are supported by the current SDK
   */
  isSupported(): boolean {
    return sdkLoader.hasDecisionSupport();
  }

  /**
   * Check if PDF export is supported
   */
  hasPDFExport(): boolean {
    return sdkLoader.hasPDFExport();
  }

  /**
   * Check if markdown export is supported
   */
  hasMarkdownExport(): boolean {
    return sdkLoader.hasMarkdownExport();
  }

  /**
   * Parse a decision from YAML string
   */
  async parseDecisionYaml(yaml: string): Promise<Decision | null> {
    // Try SDK first if supported
    if (this.isSupported()) {
      const sdk = await sdkLoader.load();
      if (sdk.parse_decision_yaml) {
        try {
          const resultJson = sdk.parse_decision_yaml(yaml);
          const sdkDecision = JSON.parse(resultJson);

          if (sdkDecision.error) {
            throw new Error(sdkDecision.error);
          }

          // Convert from SDK camelCase to frontend snake_case
          return sdkDecisionToFrontend(sdkDecision);
        } catch (error) {
          console.warn('[DecisionService] SDK parse failed, trying fallback:', error);
        }
      }
    }

    // Fallback: Parse YAML directly using js-yaml
    return this.parseDecisionYamlFallback(yaml);
  }

  /**
   * Fallback parser for decisions when SDK is not available
   */
  private async parseDecisionYamlFallback(yamlContent: string): Promise<Decision | null> {
    try {
      const jsYaml = await import('js-yaml');
      const parsed = jsYaml.load(yamlContent) as Record<string, unknown>;

      if (!parsed || typeof parsed !== 'object') {
        console.error('[DecisionService] Invalid YAML content');
        return null;
      }

      // Handle both camelCase (SDK) and snake_case (legacy) field names
      const decision: Decision = {
        id: (parsed.id as string) || crypto.randomUUID(),
        number: (parsed.number as number) || 0,
        title: (parsed.title as string) || 'Untitled Decision',
        status: ((parsed.status as string) || 'draft') as DecisionStatus,
        category: ((parsed.category as string) || 'architecture') as DecisionCategory,
        context: (parsed.context as string) || '',
        decision: (parsed.decision as string) || '',
        consequences: (parsed.consequences as string) || '',
        options: Array.isArray(parsed.options) ? (parsed.options as DecisionOption[]) : [],
        domain_id: (parsed.domainId as string) || (parsed.domain_id as string),
        workspace_id: (parsed.workspaceId as string) || (parsed.workspace_id as string),
        authors: Array.isArray(parsed.authors) ? (parsed.authors as string[]) : [],
        deciders: Array.isArray(parsed.deciders) ? (parsed.deciders as string[]) : [],
        tags: (parsed.tags as string[]) || undefined,
        created_at:
          (parsed.createdAt as string) || (parsed.created_at as string) || new Date().toISOString(),
        updated_at:
          (parsed.updatedAt as string) || (parsed.updated_at as string) || new Date().toISOString(),
        decided_at: (parsed.decidedAt as string) || (parsed.decided_at as string),
        superseded_by: (parsed.supersededBy as string) || (parsed.superseded_by as string),
      };

      console.log(`[DecisionService] Parsed decision via fallback: ${decision.title}`);
      return decision;
    } catch (error) {
      console.error('[DecisionService] Fallback parse failed:', error);
      return null;
    }
  }

  /**
   * Parse a decision index from YAML string
   */
  async parseDecisionIndexYaml(yaml: string): Promise<DecisionIndex | null> {
    if (!this.isSupported()) {
      return null;
    }

    const sdk = await sdkLoader.load();
    if (!sdk.parse_decision_index_yaml) {
      return null;
    }

    try {
      const resultJson = sdk.parse_decision_index_yaml(yaml);
      const sdkIndex = JSON.parse(resultJson);

      if (sdkIndex.error) {
        throw new Error(sdkIndex.error);
      }

      // Convert from SDK camelCase to frontend snake_case
      return sdkDecisionIndexToFrontend(sdkIndex);
    } catch (error) {
      console.error('[DecisionService] Failed to parse decision index YAML:', error);
      return null;
    }
  }

  /**
   * Export a decision to YAML string
   */
  async exportDecisionToYaml(decision: Decision): Promise<string | null> {
    if (!this.isSupported()) {
      throw new Error('Decision features require SDK 1.14.0+');
    }

    const sdk = await sdkLoader.load();
    if (!sdk.export_decision_to_yaml) {
      throw new Error('export_decision_to_yaml method not available in SDK');
    }

    try {
      // Convert from frontend snake_case to SDK camelCase
      const sdkDecision = frontendDecisionToSDK(decision);
      const decisionJson = JSON.stringify(sdkDecision);
      const yaml = sdk.export_decision_to_yaml(decisionJson);
      return yaml;
    } catch (error) {
      console.error('[DecisionService] Failed to export decision to YAML:', error);
      throw error;
    }
  }

  /**
   * Export a decision to Markdown string
   */
  async exportDecisionToMarkdown(decision: Decision, branding?: BrandingConfig): Promise<string> {
    // Try SDK export first
    if (this.hasMarkdownExport()) {
      const sdk = await sdkLoader.load();

      try {
        // Convert from frontend snake_case to SDK camelCase
        const sdkDecision = frontendDecisionToSDK(decision);
        const decisionJson = JSON.stringify(sdkDecision);

        // Use branded markdown if branding provided
        if (branding && sdk.export_decision_to_branded_markdown) {
          const brandingJson = JSON.stringify(branding);
          return sdk.export_decision_to_branded_markdown(decisionJson, brandingJson);
        }

        // Use standard markdown
        if (sdk.export_decision_to_markdown) {
          return sdk.export_decision_to_markdown(decisionJson);
        }
      } catch (error) {
        console.warn('[DecisionService] SDK markdown export failed, using fallback:', error);
      }
    }

    // Fallback to client-side markdown generation
    return this.generateMarkdown(decision);
  }

  /**
   * Export a decision to PDF (SDK 1.14.0+)
   * Returns base64-encoded PDF data
   */
  async exportDecisionToPDF(
    decision: Decision,
    branding?: BrandingConfig
  ): Promise<PDFExportResult> {
    if (!this.hasPDFExport()) {
      throw new Error('PDF export requires SDK 1.14.0+');
    }

    const sdk = await sdkLoader.load();
    if (!sdk.export_decision_to_pdf) {
      throw new Error('export_decision_to_pdf method not available in SDK');
    }

    try {
      // Convert from frontend snake_case to SDK camelCase
      const sdkDecision = frontendDecisionToSDK(decision);
      const decisionJson = JSON.stringify(sdkDecision);

      // Use provided branding or default
      const brandingToUse = branding || DEFAULT_BRANDING;
      const brandingJson = JSON.stringify(brandingToUse);

      const resultJson = sdk.export_decision_to_pdf(decisionJson, brandingJson);
      const result = JSON.parse(resultJson);

      if (result.error) {
        throw new Error(result.error);
      }

      return {
        data: result.data || result.pdf_data || result.pdfData,
        filename:
          result.filename ||
          `ADR-${formatDecisionNumber(decision.number)}-${decision.title.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.pdf`,
        mimeType: 'application/pdf',
      };
    } catch (error) {
      console.error('[DecisionService] Failed to export decision to PDF:', error);
      throw error;
    }
  }

  /**
   * Get default PDF branding from SDK
   */
  async getDefaultPDFBranding(): Promise<BrandingConfig> {
    if (!this.hasPDFExport()) {
      return DEFAULT_BRANDING;
    }

    const sdk = await sdkLoader.load();
    if (!sdk.get_default_pdf_branding) {
      return DEFAULT_BRANDING;
    }

    try {
      const brandingJson = sdk.get_default_pdf_branding();
      return JSON.parse(brandingJson);
    } catch {
      return DEFAULT_BRANDING;
    }
  }

  /**
   * Get default Markdown branding from SDK
   */
  async getDefaultMarkdownBranding(): Promise<BrandingConfig> {
    if (!this.hasMarkdownExport()) {
      return DEFAULT_BRANDING;
    }

    const sdk = await sdkLoader.load();
    if (!sdk.get_default_markdown_branding) {
      return DEFAULT_BRANDING;
    }

    try {
      const brandingJson = sdk.get_default_markdown_branding();
      return JSON.parse(brandingJson);
    } catch {
      return DEFAULT_BRANDING;
    }
  }

  /**
   * Create a new decision using SDK
   */
  async createDecisionViaSDK(
    number: number,
    title: string,
    context: string,
    decisionText: string
  ): Promise<Decision | null> {
    if (!this.isSupported()) {
      return null;
    }

    const sdk = await sdkLoader.load();
    if (!sdk.create_decision) {
      return null;
    }

    try {
      const resultJson = sdk.create_decision(number, title, context, decisionText);
      const sdkDecision = JSON.parse(resultJson);

      if (sdkDecision.error) {
        throw new Error(sdkDecision.error);
      }

      // Convert from SDK camelCase to frontend snake_case
      return sdkDecisionToFrontend(sdkDecision);
    } catch (error) {
      console.error('[DecisionService] Failed to create decision via SDK:', error);
      return null;
    }
  }

  /**
   * Create a new empty decision index using SDK
   */
  async createDecisionIndexViaSDK(): Promise<DecisionIndex | null> {
    if (!this.isSupported()) {
      return null;
    }

    const sdk = await sdkLoader.load();
    if (!sdk.create_decision_index) {
      return null;
    }

    try {
      const resultJson = sdk.create_decision_index();
      const sdkIndex = JSON.parse(resultJson);

      if (sdkIndex.error) {
        throw new Error(sdkIndex.error);
      }

      // Convert from SDK camelCase to frontend snake_case
      return sdkDecisionIndexToFrontend(sdkIndex);
    } catch (error) {
      console.error('[DecisionService] Failed to create decision index via SDK:', error);
      return null;
    }
  }

  /**
   * Add a decision to the index using SDK
   */
  async addDecisionToIndex(
    index: DecisionIndex,
    decision: Decision,
    filename: string
  ): Promise<DecisionIndex | null> {
    if (!this.isSupported()) {
      return null;
    }

    const sdk = await sdkLoader.load();
    if (!sdk.add_decision_to_index) {
      return null;
    }

    try {
      // Convert to SDK format
      const sdkIndex = frontendDecisionIndexToSDK(index);
      const sdkDecision = frontendDecisionToSDK(decision);

      const indexJson = JSON.stringify(sdkIndex);
      const decisionJson = JSON.stringify(sdkDecision);
      const resultJson = sdk.add_decision_to_index(indexJson, decisionJson, filename);
      const result = JSON.parse(resultJson);

      if (result.error) {
        throw new Error(result.error);
      }

      // Convert back to frontend format
      return sdkDecisionIndexToFrontend(result);
    } catch (error) {
      console.error('[DecisionService] Failed to add decision to index:', error);
      return null;
    }
  }

  /**
   * Export decision index to YAML
   */
  async exportDecisionIndexToYaml(index: DecisionIndex): Promise<string | null> {
    if (!this.isSupported()) {
      return null;
    }

    const sdk = await sdkLoader.load();
    if (!sdk.export_decision_index_to_yaml) {
      return null;
    }

    try {
      const sdkIndex = frontendDecisionIndexToSDK(index);
      const indexJson = JSON.stringify(sdkIndex);
      return sdk.export_decision_index_to_yaml(indexJson);
    } catch (error) {
      console.error('[DecisionService] Failed to export decision index to YAML:', error);
      return null;
    }
  }

  // ============================================================
  // Higher-level methods that work with in-memory data
  // These don't require file I/O and work with decision arrays
  // ============================================================

  /**
   * Load a single decision by ID from an array of decisions
   */
  findDecisionById(decisions: Decision[], decisionId: string): Decision | null {
    return decisions.find((d) => d.id === decisionId) ?? null;
  }

  /**
   * Filter decisions by criteria
   */
  filterDecisions(decisions: Decision[], filter: DecisionFilter): Decision[] {
    let filtered = [...decisions];

    if (filter.domain_id) {
      filtered = filtered.filter((d) => d.domain_id === filter.domain_id);
    }

    if (filter.status && filter.status.length > 0) {
      filtered = filtered.filter((d) => filter.status!.includes(d.status));
    }

    if (filter.category && filter.category.length > 0) {
      filtered = filtered.filter((d) => filter.category!.includes(d.category));
    }

    if (filter.search) {
      const searchLower = filter.search.toLowerCase();
      filtered = filtered.filter(
        (d) =>
          d.title.toLowerCase().includes(searchLower) ||
          d.context.toLowerCase().includes(searchLower) ||
          d.decision.toLowerCase().includes(searchLower)
      );
    }

    if (filter.tags && filter.tags.length > 0) {
      filtered = filtered.filter((d) => {
        if (!d.tags) return false;
        return filter.tags!.some((filterTag) =>
          d.tags!.some((t) => {
            if (typeof t === 'string') return t === filterTag;
            if ('value' in t) return t.value === filterTag;
            return false;
          })
        );
      });
    }

    return filtered;
  }

  /**
   * Create a new decision object (client-side)
   * @param data Decision data
   * @param number Optional timestamp-based number (YYMMDDHHmm). If not provided, generates one.
   */
  createDecision(
    data: {
      title: string;
      category: DecisionCategory;
      context: string;
      decision: string;
      consequences?: string;
      options?: DecisionOption[];
      domain_id?: string;
      authors?: string[];
    },
    number?: number
  ): Decision {
    const now = new Date().toISOString();
    return {
      id: crypto.randomUUID(),
      number: number ?? generateDecisionNumber(),
      title: data.title,
      status: DecisionStatus.Draft,
      category: data.category,
      context: data.context,
      decision: data.decision,
      consequences: data.consequences ?? '',
      options: data.options ?? [],
      domain_id: data.domain_id,
      authors: data.authors ?? [],
      created_at: now,
      updated_at: now,
    };
  }

  /**
   * Update a decision object
   */
  updateDecision(decision: Decision, updates: Partial<Decision>): Decision {
    return {
      ...decision,
      ...updates,
      id: decision.id, // Preserve ID
      number: decision.number, // Preserve number
      created_at: decision.created_at, // Preserve created_at
      updated_at: new Date().toISOString(),
    };
  }

  /**
   * Change decision status with validation
   */
  changeStatus(decision: Decision, newStatus: DecisionStatus, supersededById?: string): Decision {
    if (!isValidStatusTransition(decision.status, newStatus)) {
      throw new Error(`Invalid status transition from ${decision.status} to ${newStatus}`);
    }

    const updates: Partial<Decision> = {
      status: newStatus,
    };

    // Set decided_at for terminal states
    if (newStatus === DecisionStatus.Accepted || newStatus === DecisionStatus.Rejected) {
      updates.decided_at = new Date().toISOString();
    }

    // Handle superseded status
    if (newStatus === DecisionStatus.Superseded) {
      if (!supersededById) {
        throw new Error('supersededById is required when superseding a decision');
      }
      updates.superseded_by = supersededById;
    }

    return this.updateDecision(decision, updates);
  }

  /**
   * Create a decision index entry from a decision
   */
  createIndexEntry(decision: Decision): DecisionIndexEntry {
    return {
      id: decision.id,
      number: decision.number,
      title: decision.title,
      status: decision.status,
      category: decision.category,
      domain_id: decision.domain_id,
      created_at: decision.created_at,
      updated_at: decision.updated_at,
    };
  }

  /**
   * Generate markdown for a decision (fallback)
   */
  private generateMarkdown(decision: Decision): string {
    const lines: string[] = [
      `# ${formatDecisionNumber(decision.number)}. ${decision.title}`,
      '',
      `**Status:** ${decision.status}`,
      `**Category:** ${decision.category}`,
      `**Date:** ${new Date(decision.created_at).toLocaleDateString()}`,
      '',
    ];

    if (decision.deciders && decision.deciders.length > 0) {
      lines.push(`**Deciders:** ${decision.deciders.join(', ')}`);
      lines.push('');
    }

    lines.push('## Context');
    lines.push('');
    lines.push(decision.context);
    lines.push('');

    lines.push('## Decision');
    lines.push('');
    lines.push(decision.decision);
    lines.push('');

    if (decision.options && decision.options.length > 0) {
      lines.push('## Considered Options');
      lines.push('');
      for (const option of decision.options) {
        lines.push(`### ${option.title}`);
        lines.push('');
        lines.push(option.description);
        lines.push('');
        if (option.pros.length > 0) {
          lines.push('**Pros:**');
          for (const pro of option.pros) {
            lines.push(`- ${pro}`);
          }
          lines.push('');
        }
        if (option.cons.length > 0) {
          lines.push('**Cons:**');
          for (const con of option.cons) {
            lines.push(`- ${con}`);
          }
          lines.push('');
        }
      }
    }

    if (decision.consequences) {
      lines.push('## Consequences');
      lines.push('');
      lines.push(decision.consequences);
      lines.push('');
    }

    if (decision.superseded_by) {
      lines.push('---');
      lines.push('');
      lines.push(`*This decision has been superseded by [ADR-${decision.superseded_by}]*`);
    }

    return lines.join('\n');
  }

  /**
   * Get decisions by status
   */
  getDecisionsByStatus(decisions: Decision[], status: DecisionStatus): Decision[] {
    return this.filterDecisions(decisions, { status: [status] });
  }

  /**
   * Get accepted decisions
   */
  getAcceptedDecisions(decisions: Decision[]): Decision[] {
    return this.getDecisionsByStatus(decisions, DecisionStatus.Accepted);
  }

  /**
   * Get draft decisions
   */
  getDraftDecisions(decisions: Decision[]): Decision[] {
    return this.getDecisionsByStatus(decisions, DecisionStatus.Draft);
  }

  /**
   * Get proposed decisions
   */
  getProposedDecisions(decisions: Decision[]): Decision[] {
    return this.getDecisionsByStatus(decisions, DecisionStatus.Proposed);
  }

  /**
   * Download a PDF from base64 data
   * Utility method for UI components
   */
  downloadPDF(pdfResult: PDFExportResult): void {
    const byteCharacters = atob(pdfResult.data);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    const blob = new Blob([byteArray], { type: pdfResult.mimeType });

    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = pdfResult.filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}

// Export singleton instance
export const decisionService = new DecisionService();
