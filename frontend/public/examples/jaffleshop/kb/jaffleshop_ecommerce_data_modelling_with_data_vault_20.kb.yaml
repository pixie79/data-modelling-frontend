id: 3f8a2b1c-9d4e-4f5a-8c7b-6e5d4c3b2a1f
number: 2501111000
title: Data Modelling with Data Vault 2.0
articleType: guide
status: published
domainId: d9004c83-fd63-43fe-afb8-77726c3e276e
workspaceId: f47ac10b-58cc-4372-a567-0e02b2c3d479
summary: Comprehensive guide to Data Vault 2.0 (DV2) modelling methodology, including naming conventions, hash key generation, satellite patterns, and performance optimization through hash-based joins.
content: |
  # Data Modelling with Data Vault 2.0

  ## Introduction

  Data Vault 2.0 (DV2) is a modern data modelling methodology designed for
  enterprise data warehouses. It provides a scalable, flexible, and auditable
  approach to storing historical data while supporting agile development practices.

  This guide covers the key concepts, naming conventions, and implementation
  patterns used in our Data Vault 2.0 implementation.

  ## Core Components

  Data Vault 2.0 consists of three primary entity types:

  ### Hubs

  Hubs represent **business keys** - the unique identifiers for business entities.
  They contain only the business key, a hash key, and audit columns.

  **Example: Customer Hub**
  ```sql
  CREATE TABLE hub_customer (
      sys_hk_hub         BINARY(32) NOT NULL,  -- SHA256 hash key
      customer_id        VARCHAR(50) NOT NULL,  -- Business key
      sys_load_dts       TIMESTAMP NOT NULL,    -- Load timestamp
      sys_record_source  VARCHAR(100) NOT NULL  -- Source system
  );
  ```

  ### Links

  Links represent **relationships** between business entities. They connect
  two or more hubs and capture the association between business keys.

  **Example: Order-Customer Link**
  ```sql
  CREATE TABLE lnk_order_customer (
      sys_hk_lnk         BINARY(32) NOT NULL,   -- Combined hash key
      sys_hk_hub_order   BINARY(32) NOT NULL,   -- FK to hub_order
      sys_hk_hub_customer BINARY(32) NOT NULL,  -- FK to hub_customer
      sys_load_dts       TIMESTAMP NOT NULL,
      sys_record_source  VARCHAR(100) NOT NULL
  );
  ```

  ### Satellites

  Satellites store **descriptive attributes** and their history. They attach
  to hubs or links and track changes over time using hash diffs.

  **Example: Customer Satellite**
  ```sql
  CREATE TABLE sat_customer_details (
      sys_hk_hub         BINARY(32) NOT NULL,   -- FK to hub_customer
      sys_load_dts       TIMESTAMP NOT NULL,    -- Load timestamp
      sys_hd_sat         BINARY(32) NOT NULL,   -- Hash diff
      customer_name      VARCHAR(200),
      email              VARCHAR(255),
      phone              VARCHAR(50),
      sys_record_source  VARCHAR(100) NOT NULL
  );
  ```

  ## Naming Conventions

  We use **snake_case** for all entity names and follow a consistent prefix
  pattern for system-generated columns:

  ### System Column Prefixes

  | Prefix | Full Name | Description |
  |--------|-----------|-------------|
  | `sys_` | System | Prefix for all system-generated entities |
  | `sys_ok` | Ordering Key | Pipe-delimited concatenation for ordering |
  | `sys_hk_hub` | Hub Hash Key | SHA256 hash key for hub tables |
  | `sys_hk_lnk` | Link Hash Key | Combined SHA256 of hub hash keys |
  | `sys_hd_sat` | Satellite Hash Diff | Hash over satellite attributes |
  | `sys_cl` | Clustering Key | Grouping key for auto-clustering |
  | `sys_load_dts` | Load Date Timestamp | Technical load timestamp for audit |
  | `sys_record_source` | Record Source | Data origin identifier |

  ### Abbreviation Reference

  - **sys** = System (prefix for system-generated entities)
  - **cl** = Clustering/Grouping keys for auto-clustering
  - **sat** = Satellite
  - **load_dts** = Load Date Timestamp
  - **ok** = Ordering Key
  - **hk** = Hash Key
  - **hd** = Hash Diff
  - **hub** = Hub table
  - **lnk** = Link table

  ## Hash Key Generation

  Hash keys are the cornerstone of Data Vault 2.0, enabling fast joins and
  ensuring data integrity.

  ### Ordering Keys (sys_ok)

  The ordering key is a **pipe-delimited concatenation** of business keys
  that forms the basis for hash key generation.

  **Structure:**
  ```
  sys_ok = <sys_record_source>|<business_key_1>|<business_key_2>|...
  ```

  **Example:**
  ```sql
  -- For a customer from the POS system with ID 'CUST-12345'
  sys_ok = 'pos_system|CUST-12345'

  -- For an order with multiple keys
  sys_ok = 'ecommerce|ORD-2024-001|CUST-12345'
  ```

  **Important:** Always use the pipe (`|`) delimiter between components.

  ### Hub Hash Keys (sys_hk_hub)

  Hub hash keys are generated by applying **SHA256** to the ordering key.

  **Formula:**
  ```sql
  sys_hk_hub = SHA256(UPPER(TRIM(sys_ok)))
  ```

  **Example Implementation:**
  ```sql
  -- Generate hub hash key for customer
  SELECT
      SHA256(
          UPPER(TRIM(
              CONCAT(sys_record_source, '|', customer_id)
          ))
      ) AS sys_hk_hub,
      customer_id,
      CURRENT_TIMESTAMP AS sys_load_dts,
      sys_record_source
  FROM source_customers;
  ```

  ### Link Hash Keys (sys_hk_lnk)

  Link hash keys are generated by combining the hash keys of the related hubs.

  **Formula:**
  ```sql
  sys_hk_lnk = SHA256(CONCAT(sys_hk_hub_1, sys_hk_hub_2, ...))
  ```

  **Example Implementation:**
  ```sql
  -- Generate link hash key for order-customer relationship
  SELECT
      SHA256(CONCAT(
          hub_order.sys_hk_hub,
          hub_customer.sys_hk_hub
      )) AS sys_hk_lnk,
      hub_order.sys_hk_hub AS sys_hk_hub_order,
      hub_customer.sys_hk_hub AS sys_hk_hub_customer,
      CURRENT_TIMESTAMP AS sys_load_dts,
      'order_integration' AS sys_record_source
  FROM staging_orders s
  JOIN hub_order ON s.order_id = hub_order.order_id
  JOIN hub_customer ON s.customer_id = hub_customer.customer_id;
  ```

  ### Hash Diffs (sys_hd_sat)

  Hash diffs detect changes in satellite attributes. They are computed over
  **all descriptive attributes except sys_load_dts**.

  **Formula:**
  ```sql
  sys_hd_sat = SHA256(CONCAT(attr_1, '|', attr_2, '|', ..., attr_n))
  ```

  **Example Implementation:**
  ```sql
  -- Generate hash diff for customer satellite
  SELECT
      hub.sys_hk_hub,
      CURRENT_TIMESTAMP AS sys_load_dts,
      SHA256(CONCAT(
          COALESCE(customer_name, ''),
          '|',
          COALESCE(email, ''),
          '|',
          COALESCE(phone, '')
      )) AS sys_hd_sat,
      customer_name,
      email,
      phone,
      sys_record_source
  FROM staging_customers stg
  JOIN hub_customer hub ON stg.customer_id = hub.customer_id
  WHERE NOT EXISTS (
      -- Only insert if hash diff has changed
      SELECT 1 FROM sat_customer_details sat
      WHERE sat.sys_hk_hub = hub.sys_hk_hub
        AND sat.sys_hd_sat = SHA256(CONCAT(
              COALESCE(stg.customer_name, ''),
              '|',
              COALESCE(stg.email, ''),
              '|',
              COALESCE(stg.phone, '')
          ))
  );
  ```

  ## Record Source Naming

  The `sys_record_source` column identifies the origin of data. Use a
  consistent naming pattern:

  **Format:**
  ```
  <source_system_or_topic_name>
  ```

  **Examples:**
  - `pos_system` - Point of Sale system
  - `ecommerce_api` - E-commerce API integration
  - `crm_salesforce` - Salesforce CRM
  - `kafka_orders_topic` - Kafka orders topic
  - `manual_data_entry` - Manual data entry process

  ## Benefits of Data Vault 2.0

  ### 1. **Scalability**
  - Hash keys enable parallel loading without sequence dependencies
  - Horizontal scaling across distributed systems
  - Consistent performance regardless of data volume

  ### 2. **Flexibility**
  - Add new sources without restructuring existing models
  - Extend satellites without affecting other components
  - Support for late-arriving data and corrections

  ### 3. **Auditability**
  - Complete history of all changes via satellites
  - Full lineage through sys_record_source
  - Immutable audit trail with sys_load_dts

  ### 4. **Agile Development**
  - Independent development of hubs, links, and satellites
  - Incremental delivery of new business entities
  - Reduced refactoring when requirements change

  ### 5. **Performance**
  - Hash-based joins are faster than multi-column joins
  - Fixed-width hash keys optimize index performance
  - Clustering keys improve query performance

  ## Joining Tables for Performance

  One of the key performance advantages of Data Vault 2.0 is the use of
  **hash keys for joins**. Instead of joining on multiple business key
  columns, you join on a single hash key column.

  ### Traditional Join (Slower)
  ```sql
  -- Multi-column join on business keys
  SELECT *
  FROM orders o
  JOIN customers c ON o.customer_id = c.customer_id
                  AND o.region = c.region
                  AND o.source = c.source;
  ```

  ### Hash Key Join (Faster)
  ```sql
  -- Single-column join on hash key
  SELECT *
  FROM sat_order_details sod
  JOIN hub_order ho ON sod.sys_hk_hub = ho.sys_hk_hub
  JOIN lnk_order_customer loc ON ho.sys_hk_hub = loc.sys_hk_hub_order
  JOIN hub_customer hc ON loc.sys_hk_hub_customer = hc.sys_hk_hub
  JOIN sat_customer_details scd ON hc.sys_hk_hub = scd.sys_hk_hub;
  ```

  ### Performance Benefits of Hash Key Joins

  1. **Fixed-Width Columns**: SHA256 produces 32-byte keys, optimized for
     indexing regardless of original key complexity.

  2. **Single Column Comparison**: One hash comparison vs. multiple column
     comparisons reduces CPU overhead.

  3. **Index Efficiency**: B-tree indexes on fixed-width columns are more
     compact and faster to traverse.

  4. **Parallel Processing**: Hash distribution enables even data distribution
     across nodes in distributed systems.

  ### Clustering for Additional Performance

  Use `sys_cl` clustering keys to optimize table storage:

  ```sql
  -- Create table with clustering
  CREATE TABLE sat_order_details (
      sys_hk_hub    BINARY(32) NOT NULL,
      sys_load_dts  TIMESTAMP NOT NULL,
      sys_hd_sat    BINARY(32) NOT NULL,
      sys_cl        VARCHAR(50),  -- Clustering key (e.g., region, date)
      order_amount  DECIMAL(10,2),
      order_status  VARCHAR(20),
      sys_record_source VARCHAR(100) NOT NULL
  )
  CLUSTER BY (sys_cl, sys_hk_hub);
  ```

  ## Best Practices

  ### Hash Key Computation
  - Always **UPPER()** and **TRIM()** business keys before hashing
  - Use **COALESCE()** to handle NULL values consistently
  - Maintain **consistent ordering** of concatenated values

  ### Satellite Design
  - Group related attributes in the same satellite
  - Create separate satellites for different rates of change
  - Include sys_hd_sat to detect actual changes

  ### Loading Patterns
  - Load hubs first, then links, then satellites
  - Use hash key lookups for efficient hub/link resolution
  - Implement change detection using sys_hd_sat comparison

  ### Naming Standards
  - Prefix hubs with `hub_`
  - Prefix links with `lnk_`
  - Prefix satellites with `sat_`
  - Use descriptive names: `sat_customer_contact`, `sat_customer_demographics`

  ## Example: Complete Customer Entity

  ```sql
  -- Hub: Business key storage
  CREATE TABLE hub_customer (
      sys_hk_hub         BINARY(32) PRIMARY KEY,
      customer_id        VARCHAR(50) NOT NULL,
      sys_load_dts       TIMESTAMP NOT NULL,
      sys_record_source  VARCHAR(100) NOT NULL
  );

  -- Satellite: Contact information (changes frequently)
  CREATE TABLE sat_customer_contact (
      sys_hk_hub         BINARY(32) NOT NULL,
      sys_load_dts       TIMESTAMP NOT NULL,
      sys_hd_sat         BINARY(32) NOT NULL,
      email              VARCHAR(255),
      phone              VARCHAR(50),
      address            VARCHAR(500),
      sys_record_source  VARCHAR(100) NOT NULL,
      PRIMARY KEY (sys_hk_hub, sys_load_dts)
  );

  -- Satellite: Demographics (changes rarely)
  CREATE TABLE sat_customer_demographics (
      sys_hk_hub         BINARY(32) NOT NULL,
      sys_load_dts       TIMESTAMP NOT NULL,
      sys_hd_sat         BINARY(32) NOT NULL,
      date_of_birth      DATE,
      gender             VARCHAR(20),
      income_bracket     VARCHAR(50),
      sys_record_source  VARCHAR(100) NOT NULL,
      PRIMARY KEY (sys_hk_hub, sys_load_dts)
  );

  -- Link: Customer to Loyalty Program
  CREATE TABLE lnk_customer_loyalty (
      sys_hk_lnk              BINARY(32) PRIMARY KEY,
      sys_hk_hub_customer     BINARY(32) NOT NULL,
      sys_hk_hub_loyalty      BINARY(32) NOT NULL,
      sys_load_dts            TIMESTAMP NOT NULL,
      sys_record_source       VARCHAR(100) NOT NULL
  );
  ```

  ## Conclusion

  Data Vault 2.0 provides a robust, scalable approach to data warehousing
  that supports historical tracking, multiple source integration, and
  high-performance querying through hash-based joins.

  By following the naming conventions and patterns outlined in this guide,
  you can build a consistent, maintainable data vault that grows with your
  organization's needs.
authors:
  - data-architecture-team@jaffleshop.example
reviewers:
  - data-governance@jaffleshop.example
tags:
  - '[object Object]'
  - '[object Object]'
  - '[object Object]'
  - '[object Object]'
  - '[object Object]'
createdAt: 2026-01-11T15:39:33.858Z
updatedAt: 2026-01-11T15:39:33.858Z
